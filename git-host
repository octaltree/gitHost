#!/usr/bin/python3
# written in Python 3.4.3

from enum import Enum
import sys
#import traceback
import argparse
import urllib.parse
import urllib.request
import urllib.error
import json
import re
import datetime
#import logging

# undefined :: a
undefined = None

# USERAGENT :: Str
USERAGENT = "gitHost/0.0.1.0" # 何かしら指定しないとhubに怒られる
URLOAUTHCALLBACK = "http://github.com/octaltree" # :: Str
TIMEFORMAT = "%Y,%j,%H,%M,%S,%f"

class Host(Enum):
    hub = 1
    bucket = 2
    lab = 3

class OAuthConsumer:
    # :: OAuthConsumer -> Host -> Str -> Str -> OAuthConsumer -> a
    def __init__(self, host, consumerkey, consumersecret):
        self.host = host
        self.key = consumerkey
        self.secret = consumersecret
        return None
    #__str__ = lambda self: '{{"key": "{0}", "secret": "{1}"}} :: OAuthConsumer'.format(self.key, self.secret)
    __str__ = lambda self: str(vars(self)) + " :: OAuthConsumer"
    host = None
    key = None# :: Str
    secret = None# :: Str

class OAuthToken:
    # :: OAuthToken -> Dict -> a
    def __init__(self, token):
        try:
            self.access_token = token['access_token']
        except KeyError:
            exit("fail at OAuthToken(" + str(token) + ")")

        self.create_at = datetime.datetime.now()
        self.token_type = token.get("token_type")
        self.scope = token.get("scope", self.scope)
        self.scope = token.get("scopes", self.scope)
        self.refresh_token = token.get("refresh_token")
        self.expires_in = token.get("expires_in") # TODO :: datetime.timedelta
        return None

    __str__ = lambda self: str(vars(self)) + " :: OAuthToken"

    access_token = None # :: Str
    refresh_token = None # :: Str
    scope = None # :: Str
    token_type = None # :: Str
    expires_in = None # :: datetime.timedelta
    created_at = None # :: datetime.datetime

# main :: IO Int
def main():
    rootp = argparse.ArgumentParser(description='manage git remote host')
    subp = rootp.add_subparsers(description='')
    repop = subp.add_parser('repo', help='manipulate remote repo')
    addp = subp.add_parser('add', help='add hosting service provider & user')
    args = rootp.parse_args()

    consumerlab = OAuthConsumer(Host.lab, '8ba20e67ea70d9622041588ecd50774ec56d005d1d363b9938803e7fe1b74179', '36b982ce8292ac99c755811b4010bf596c82172b3bc2968df8b86efdd5daca09')
    consumerbucket = OAuthConsumer(Host.bucket, 'Ev4c4krDQqHyRd2XH6', 'TvvCNhsZGwFWJ6eBM9Q2crLDUawsQ4Ar')
    consumerhub = OAuthConsumer(Host.hub, "718bd071955521ca0b6b", "1dbc0c05ab623d5e9a89023b74dbaf08cb06ce2e")
    #print(urlLabOAuthCode(consumerlab))
    #print(getLabOAuthToken(consumerlab, 'e0d9a3c6f72c7800a3a633aea55caea3dde91813c4eb466f82f70c1879cb537b'))
    #refreshbucket = "2g7VCmzNcR8p3XDWa6"
    refreshlab = "3cbccf080bd27ff6dee7d3072854fe492422e17c4810c8de5f4cb7f5d454b189"
    #print(refreshBucketOAuthToken(consumerbucket, refreshbucket))
    #print(refreshLabOAuthToken(consumerlab, refreshlab))
    return undefined

# :: OAuthToken -> json
def jsonOAuthToken(token):
    #return json.dumps(dic)
    return undefined

# :: OAuthConsumer -> Str -> OAuthToken
def getHubOAuthToken(consumer, code):
    data = urllib.parse.urlencode([
        ("client_id", consumer.key),
        ("client_secret", consumer.secret),
        ("code", code)
        ]).encode('utf-8') # :: BytesUtf8
    headers = {
            "Content-Type": "application/x-www-form-urlencoded;charset=utf-8",
            "Accept": "application/json"}
    req = urllib.request.Request("https://github.com/login/oauth/access_token",
            data, headers)
    token = json.loads(body(http(req))) # :: Dict
    try:
        return OAuthToken(token)
    except KeyError:
        exit(token)

# :: OAuthConsumer -> Str -> OAuthToken
def getLabOAuthToken(consumer, code):
    url = "https://gitlab.com/oauth/token"
    data = urllib.parse.urlencode([
        ("client_id", consumer.key),
        ("client_secret", consumer.secret),
        ("code", code),
        ("grant_type", "authorization_code"),
        ("redirect_uri", URLOAUTHCALLBACK)
        ]).encode('utf-8')
    headers = {
            "Content-Type": "application/x-www-form-urlencoded;charset=utf-8"}
    req = urllib.request.Request(url, data, headers)
    token = json.loads(body(http(req))) # :: Dict
    try:
        return OAuthToken(token)
    except KeyError:
        exit(token)

# :: OAuthConsumer -> Str -> OAuthToken
def getBucketOAuthToken(consumer, code):
    url = "https://bitbucket.org/site/oauth2/access_token"
    data = urllib.parse.urlencode([
        ("client_id", consumer.key),
        ("client_secret", consumer.secret),
        ("code", code),
        ("grant_type", "authorization_code")
        ]).encode('utf-8')
    headers = {
            "Content-Type": "application/x-www-form-urlencoded;charset=utf-8"}
    req = urllib.request.Request(url, data, headers)
    token = json.loads(body(http(req))) # :: Dict
    try:
        return OAuthToken(token)
    except KeyError:
        exit(token)

# :: OAuthConsumer -> Str -> OAuthToken
def refreshLabOAuthToken(consumer, refreshtoken):
    url = "https://gitlab.com/oauth/token"
    data = urllib.parse.urlencode([
        ("client_id", consumer.key),
        ("client_secret", consumer.secret),
        ("refresh_token", refreshtoken),
        ("grant_type", "refresh_token"),
        ("redirect_uri", URLOAUTHCALLBACK)
        ]).encode('utf-8')
    headers = {
            "Content-Type": "application/x-www-form-urlencoded;charset=utf-8"}
    req = urllib.request.Request(url, data, headers)
    token = json.loads(body(http(req))) # :: Dict
    try:
        return OAuthToken(token)
    except KeyError:
        exit(token)

# :: OAuthConsumer -> Str -> OAuthToken
def refreshBucketOAuthToken(consumer, refreshtoken):
    url = "https://bitbucket.org/site/oauth2/access_token"
    data = urllib.parse.urlencode([
        ("client_id", consumer.key),
        ("client_secret", consumer.secret),
        ("refresh_token", refreshtoken),
        ("grant_type", "refresh_token")
        ]).encode('utf-8')
    headers = {
            "Content-Type": "application/x-www-form-urlencoded;charset=utf-8"}
    req = urllib.request.Request(url, data, headers)
    token = json.loads(body(http(req))) # :: Dict
    try:
        return OAuthToken(token)
    except KeyError:
        exit(token)

# :: OAuthConsumer -> Str
urlBucketOAuthCode = lambda c: "https://bitbucket.org/site/oauth2/authorize?client_id={0}&response_type=code".format(c.key)

# :: OAuthConsumer -> Str
urlLabOAuthCode = lambda c: "https://gitlab.com/oauth/authorize?client_id={0}&response_type=code&redirect_uri={1}".format(c.key, urllib.parse.quote_plus(URLOAUTHCALLBACK))

# :: OAuthConsumer -> Str
urlHubOAuthCode = lambda c: urllib.parse.urlunparse(("https", "github.com", "/login/oauth/authorize", "",
        urllib.parse.urlencode([
            ("client_id", c.key),
            ("redirect_uri", URLOAUTHCALLBACK),
            ("scope", "public_repo,repo,user") # TODO userいらない?
            ]), ""))


# :: Dict -> Str
urlFriendlyFullNameBucketRepo = lambda repo: "{0}/{1}".format(repo['owner']['username'], repo['name'])

# :: Dict -> Str
urlFriendlyFullNameHubRepo = lambda repo: repo['full_name']

# :: Dict -> Str
urlFriendlyFullNameLabRepo = lambda repo: repo['path_with_namespace']

# :: urllib.request.Request -> IO urllib.request.HTTPResponse
def http(request):
    request.add_header("User-Agent", USERAGENT)
    try:
        return urllib.request.urlopen(request)
    except urllib.error.HTTPError as e:
        #exctype, excval, exctraceback = sys.exc_info()
        print("*** Request", file=sys.stderr)
        print(" ", request.get_method(), request.full_url, file=sys.stderr)
        #print(" ", request.header_items(), file=sys.stderr)
        [print(" ", tpl, file=sys.stderr) for tpl in request.header_items()]
        print(" ", request.data, file=sys.stderr)
        print("", file=sys.stderr)
        print("*** Response", file=sys.stderr)
        print(" ", e.status, e.reason, file=sys.stderr)
        #print(" ", e.getheaders(), file=sys.stderr)
        [print(" ", tpl, file=sys.stderr) for tpl in e.getheaders()]
        print(" ", e.read(), file=sys.stderr)
        exit(1)

# :: Str -> Str -> IO urllib.request.HTTPResponse
def getOwnBucketRepos(user, token):
    url = "https://api.bitbucket.org/2.0/repositories/{0}".format(urllib.parse.quote(user))
    headers = { "Authorization": "Bearer {0}".format(token)}
    return http(urllib.request.Request(url, headers=headers))

# :: Str -> Str -> IO urllib.request.HTTPResponse
def getOwnHubRepos(user, token):
    url = "https://api.github.com/user/repos"
    headers = { "Authorization": "token {0}".format(token)}
    return http(urllib.request.Request(url, headers=headers))

# :: Str -> Str -> IO urllib.request.HTTPResponse
def getOwnLabRepos(user, token):
    url = "https://gitlab.com/api/v3/projects"
    headers = { "PRIVATE-TOKEN": "{0}".format(token)}
    return http(urllib.request.Request(url, headers=headers))

# :: urllib.request.HTTPResponse -> Str
def body(response):
    contenttype = response.getheader('Content-Type', default='charset=utf-8')
    charset = charsetFromContentType(contenttype)
    if charset is None :
        charset = 'utf-8'
    return response.read().decode(charset)

# :: Str -> Str
def charsetFromContentType(str):
    lines = str.split(';')
    charsets = list(filter(lambda s: 'charset' in s, lines))
    if len(charsets) == 0 :
        return None
    charset = charsets.pop().replace(' ', '')
    mat = re.match('^charset=(.*)[;]*$', charset)
    return mat.group(1) if mat else None

def newOwnBucketRepo():
    return undefined

def newOwnHubRepo():
    return undefined

def newOwnLabRepo():
    return undefined


if __name__ == "__main__" :
  exit(main())

# vim:fenc=utf-8 ff=unix ft=python ts=4 sw=4 sts=4 si et fdm=indent fdl=0 fdn=1:
# vim:cinw=if,elif,else,for,while,try,except,finally,def,class:
