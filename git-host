#!/usr/bin/python3
# written in Python 3.4.3

from enum import Enum
import sys
#import traceback
import argparse
import urllib.parse
import urllib.request
import urllib.error
import json
import re
import datetime
#import logging

# undefined :: a
undefined = None

# USERAGENT :: Str
USERAGENT = 'gitHost/0.0.1.0' # 何かしら指定しないとhubに怒られる
URLOAUTHCALLBACK = "http://github.com/octaltree" # :: Str
class OAuthConsumer:
    # :: OAuthConsumer -> Str -> Str -> OAuthConsumer -> a
    def __init__(self, consumerkey, consumersecret):
        self.key = consumerkey
        self.secret = consumersecret
        return None
    #__str__ = lambda self: '{{"key": "{0}", "secret": "{1}"}} :: OAuthConsumer'.format(self.key, self.secret)
    __str__ = lambda self: str(vars(self)) + " :: OAuthConsumer"
    key = None# :: Str
    secret = None# :: Str

class OAuthToken:
    # :: OAuthToken -> a
    def __init__(self, accesstoken, tokentype=None, scope=None, refreshtoken=None, validterm=None, createat=None):
        self.accesstoken = accesstoken
        self.tokentype = tokentype
        self.scope = scope
        self.refreshtoken = refreshtoken
        self.validterm = validterm
        self.createat = createat
        return None
    __str__ = lambda self: str(vars(self)) + " :: OAuthToken"
    accesstoken = None # :: Str
    refreshtoken = None # :: Str
    scope = None # :: Str
    tokentype = None # :: Str
    validterm = None # :: datetime.timedelta
    createdat = None # :: datetime.datetime

# main :: IO Int
def main():
    rootp = argparse.ArgumentParser(description='manage git remote host')
    subp = rootp.add_subparsers(description='')
    repop = subp.add_parser('repo', help='manipulate remote repo')
    addp = subp.add_parser('add', help='add hosting service provider & user')
    args = rootp.parse_args()

    consumerlab = OAuthConsumer('8ba20e67ea70d9622041588ecd50774ec56d005d1d363b9938803e7fe1b74179', '36b982ce8292ac99c755811b4010bf596c82172b3bc2968df8b86efdd5daca09')
    consumerbucket = OAuthConsumer('Ev4c4krDQqHyRd2XH6', 'TvvCNhsZGwFWJ6eBM9Q2crLDUawsQ4Ar')
    consumerhub = OAuthConsumer("718bd071955521ca0b6b", "1dbc0c05ab623d5e9a89023b74dbaf08cb06ce2e")
    #print(urlLabOAuthCode(consumerlab))
    print(getLabOAuthToken(consumerlab, '3ed94b208284a0173af21e96f28591683e5dd00a37f3f9226b458a7639f853c6'))
    #print(refreshLabOAuthToken(consumerlab, ''))
    return undefined

# :: OAuthConsumer -> Str -> OAuthToken
def getHubOAuthToken(consumer, code):
    data = urllib.parse.urlencode([
        ("client_id", consumer.key),
        ("client_secret", consumer.secret),
        ("code", code)
        ]).encode('utf-8') # :: BytesUtf8
    headers = {
            "Content-Type": "application/x-www-form-urlencoded;charset=utf-8",
            "Accept": "application/json"}
    req = urllib.request.Request("https://github.com/login/oauth/access_token",
            data, headers)
    createat = datetime.datetime.now()
    token = json.loads(body(http(req))) # :: Dict
    try:
        return OAuthToken(token['access_token'],
                tokentype = token['token_type'],
                scope = token['scope'],
                createat = createat)
    except KeyError:
        exit(token)

# :: OAuthConsumer -> Str -> OAuthToken
def getLabOAuthToken(consumer, code):
    data = urllib.parse.urlencode([
        ("client_id", consumer.key),
        ("client_secret", consumer.secret),
        ("code", code),
        ("grant_type", "authorization_code"),
        ("redirect_uri", URLOAUTHCALLBACK)
        ]).encode('utf-8')
    headers = {
            "Content-Type": "application/x-www-form-urlencoded;charset=utf-8"}
    req = urllib.request.Request("https://gitlab.com/oauth/token",
            data, headers)
    createat = datetime.datetime.now()
    token = json.loads(body(http(req))) # :: Dict
    try:
        return OAuthToken(token['access_token'],
                tokentype = token['token_type'],
                #scope = token['scope'],
                refreshtoken = token['refresh_token'],
                validterm = token['expires_in'],
                createat = createat)
    except KeyError:
        exit(token)

def refreshLabOAuthToken(consumer, refreshtoken):
    data = urllib.parse.urlencode([
        ("client_id", consumer.key),
        ("client_secret", consumer.secret),
        ("code", refreshtoken),
        ("grant_type", "refresh_token"),
        ("redirect_uri", URLOAUTHCALLBACK)
        ]).encode('utf-8')
    headers = {
            "Content-Type": "application/x-www-form-urlencoded;charset=utf-8"}
    req = urllib.request.Request("https://gitlab.com/oauth/token",
            data, headers)
    createat = datetime.datetime.now()
    token = json.loads(body(http(req))) # :: Dict
    try:
        return OAuthToken(token['access_token'],
                tokentype = token['token_type'],
                #scope = token['scope'],
                refreshtoken = token['refresh_token'],
                validterm = token['expires_in'],
                createat = createat)
    except KeyError:
        exit(token)


# :: OAuthConsumer -> Str -> OAuthToken
def getBucketOAuthToken(consumer, code):
    return undefined

# :: OAuthConsumer -> Str
urlBucketOAuthCode = lambda c: "https://bitbucket.org/site/oauth2/authorize?client_id={0}&response_type=code".format(c.key)

# :: OAuthConsumer -> Str
urlLabOAuthCode = lambda c: "https://gitlab.com/oauth/authorize?client_id={0}&response_type=code&redirect_uri={1}".format(c.key, urllib.parse.quote_plus(URLOAUTHCALLBACK))

# :: OAuthConsumer -> Str
urlHubOAuthCode = lambda c: urllib.parse.urlunparse(("https", "github.com", "/login/oauth/authorize", "",
        urllib.parse.urlencode([
            ("client_id", c.key),
            ("redirect_uri", URLOAUTHCALLBACK),
            ("scope", "public_repo,repo,user") # TODO userいらない?
            ]), ""))


# :: Dict -> Str
urlFriendlyFullNameBucketRepo = lambda repo: "{0}/{1}".format(repo['owner']['username'], repo['name'])

# :: Dict -> Str
urlFriendlyFullNameHubRepo = lambda repo: repo['full_name']

# :: Dict -> Str
urlFriendlyFullNameLabRepo = lambda repo: repo['path_with_namespace']

# :: urllib.request.Request -> IO urllib.request.HTTPResponse
def http(request):
    request.add_header("User-Agent", USERAGENT)
    try:
        return urllib.request.urlopen(request)
    except urllib.error.HTTPError as e:
        #exctype, excval, exctraceback = sys.exc_info()
        print("*** Request", file=sys.stderr)
        print(" ", request.get_method(), request.full_url, file=sys.stderr)
        #print(" ", request.header_items(), file=sys.stderr)
        [print(" ", tpl, file=sys.stderr) for tpl in request.header_items()]
        print(" ", request.data, file=sys.stderr)
        print("", file=sys.stderr)
        print("*** Response", file=sys.stderr)
        print(" ", e.status, e.reason, file=sys.stderr)
        #print(" ", e.getheaders(), file=sys.stderr)
        [print(" ", tpl, file=sys.stderr) for tpl in e.getheaders()]
        print(" ", e.read(), file=sys.stderr)
        exit(1)

# :: Str -> Str -> IO urllib.request.HTTPResponse
def getOwnBucketRepos(user, token):
    url = "https://api.bitbucket.org/2.0/repositories/{0}".format(urllib.parse.quote(user))
    headers = { "Authorization": "Bearer {0}".format(token)}
    return http(urllib.request.Request(url, headers=headers))

# :: Str -> Str -> IO urllib.request.HTTPResponse
def getOwnHubRepos(user, token):
    url = "https://api.github.com/user/repos"
    headers = { "Authorization": "token {0}".format(token)}
    return http(urllib.request.Request(url, headers=headers))

# :: Str -> Str -> IO urllib.request.HTTPResponse
def getOwnLabRepos(user, token):
    url = "https://gitlab.com/api/v3/projects"
    headers = { "PRIVATE-TOKEN": "{0}".format(token)}
    return http(urllib.request.Request(url, headers=headers))

# :: urllib.request.HTTPResponse -> Str
def body(response):
    contenttype = response.getheader('Content-Type', default='charset=utf-8')
    charset = charsetFromContentType(contenttype)
    if charset is None :
        charset = 'utf-8'
    return response.read().decode(charset)

# :: Str -> Str
def charsetFromContentType(str):
    lines = str.split(';')
    charsets = list(filter(lambda s: 'charset' in s, lines))
    if len(charsets) == 0 :
        return None
    charset = charsets.pop().replace(' ', '')
    mat = re.match('^charset=(.*)[;]*$', charset)
    return mat.group(1) if mat else None

def newOwnBucketRepo():
    return undefined

def newOwnHubRepo():
    return undefined

def newOwnLabRepo():
    return undefined


if __name__ == "__main__" :
  exit(main())

# vim:fenc=utf-8 ff=unix ft=python ts=4 sw=4 sts=4 si et fdm=indent fdl=0 fdn=1:
# vim:cinw=if,elif,else,for,while,try,except,finally,def,class:
